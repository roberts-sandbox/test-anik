---
layout: post
title:  BORAX By Example
tags:   architecture

synopsis: In which I write a simple RIA atop BORAX.
---

# {{ page.title }}

{{ page.synopsis }}
{: .subtitle }

-----

![BORAX](/img/borax.png)
{: class=middle}

## BORAX by Example

Just for review, the most common usage pattern of a rich internet application
goes like this:

1. Visitor GETs a main page of the application; visitor can't access page and
   login form is shown
1. Visitor POSTs credentials to server
   * On failure: response contains login page (go to parent step)
   * On success: response contains redirect to original page (go to next step)
1. Visitor GETs page of application
1. Broswer makes GETs and POSTs on behalf of visitor for information
   * Responses most often contain media types ``text/html``, ``text/xml``, or
     ``application/json``
   * For ``text/html``, JavaScript plops new content into DOM
   * For ``text/xml``, JavaScript or browser applies stylesheet and plops
     transformed content into DOM
   * For ``application/json``, JavaScript using out-of-band information
     generates something to plop into the DOM or affect the current items in
     the DOM
1. Visitor interacts with application by GETting and POSTing to various URLs
1. Visitor POSTs to logout URL (go to first step)

I'll just go down the list, talk about the current state-of-the-art, then do
scrub it clean with some BORAX.

### Authentication - BOOM!

About twelve and one-half years ago, some folks from across the computer
software world got together and wrote
[HTTP Authentication: Basic and Digest Access Authentication](http://www.ietf.org/rfc/rfc2617.txt).
It describes two methods by which a user can authenticate with a server to
prove their identity. The HTTP/1.1 standard references it and the two
authentication methods "Basic" and "Digets" as the two options by which the
'WWW-Authenticate' header can work out-of-the-box. Unfortunately, while the
RFC describes the method by which a browser authenticates, it does not address
the situation where the browser or server wants to abandon the credentials.

That's right: the standard does not provide for "logout."

Oh, did I mention its age: 12-1/2 years old!? If I haven't made a mistake, I
think that describes the Paleolithic era of the Web.

In the interim, almost every single Web application has abandoned the
excellent HTTP status code **401 Unauthorized** and the "WWW-Authenticate"
header because they can't end a session, can't intercept that ugly popup box
the browser throws in front of the user, or can't bother to have to set up
the Web server to make the challenge.

It's just so much easier to present a form and keep some token in the
browser's cookies. And it's prettier. And, it's an opportunity for branding.
Until someone updates this or Kerberos becomes the Internet-wide standard for
authentication, we need something better.

Enter BORAX. BORAX registers handlers for different HTTP status codes. That's
important because we want our server to tell us the disposition of the request
which will provide us with much better processing for other types of requests
as well as authentication.

With BORAX, any managed AJAX request that returns a 401 HTTP status code will
use the registered '401 Unauthorized' handler. The default handler probes for
associated content for an authentication form or template in the following
places:

1. The body of the response if the "Content-Type" of the response equals
   ``text/html`` and the body has content
1. The body of the response if the "Content-Type" of the response equals
   ``application/x.borax-linkbase``
1. The body of the response if the "Content-Type" of the response equals
   ``multipart/related`` and the "type" parameter equals
   ``application/x.borax-renderable``
1. In the response for a "Link" header with a relation of
   "authorization-template"
1. In the ``HEAD`` of the currently loaded page for a ``link`` tag with a
   relation of "authorization-template"

Should all of these fail, BORAX will report an error to your application. If
BORAX can find any of these, then it returns an object that your application
can render into the DOM and a login form (assuming that content gets served
by any of those methods) will appear in your browser!




