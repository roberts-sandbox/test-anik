---
layout: post
title:  "Let&#39;s Make a Language: C♭ - Part 2"
tags:   C♭, language design, compilers, CLR

synopsis: In which I continue to muck about making a new language because languages are fun.
---

# {{ page.title }}

{{ page.synopsis }}
{: .subtitle }

-----

I don't know how far we'll get in this part. But, let's you and I find how.
This is comparatively advanced, 

## Readying the project

This project should create a compiler. So, we'll need an executable. If you
want to follow along, you'll need to take these steps to get started. We're
shooting for the following directory structure for this solution.

     cflat                           (Solution directory)
     +---cflat                       (Project directory)
     \---libs                        (External libraries)
         +---gplex                   (Lexer generator)
         |   +---binaries            (downloaded)
         |   +---documentation       (downloaded)
         |   +---project             (downloaded)
         |   \---testfiles           (downloaded)
         \---gppg                    (Parser generator)
             +---binaries            (downloaded)
             +---documentation       (downloaded)
             +---project             (downloaded)
             \---testfiles           (downloaded)

If you don't want to follow along, you can head over to GitHub and check out
the repo, download the source, or whatever you can do for your platform.

1. Create a Microsoft Visual Studio 2010 C# Console Application and name it
"cflat".
1. To the project, add a "New Item..." of type "Text File." Name it
"lexer.lex". Type the following into the file:  
`  `  
`  %namespace cflat`  
`  %%`  
`  `  
`  `
1. To the project, add a "New Item..." of type "Text File." Name it
"parser.y". For its content, type:  
`  `  
`  %namespace cflat`  
`  %%`  
`  fake:;`  
`  %%`  
`  internal Parser(Scanner led) : base(lex) {}`  
`  `  
`  `
1. Close Visual Studio and should it prompt you to save anything, reply in the
affirmative.
1. In you solution folder, create a directory named "libs".
1. Download the distribution of [gppg](http://gppg.codeplex.com "gppg") into a
directory named "gppg" in the libs directory. We'll use that for generating
parser.
1. Also, download the distribution of
[gplex](http://gplex.codeplex.com "gplex") into a directory named "gplex" in
the libs directory. We'll use that for generating the lexer.
1. Crack open the cflat.csproj file in a text editor and insert the following
XML snippet as the last nodes in the `&lt;Project&gt;` node. This will build
our C# 

{% highlight xml %}
<PropertyGroup>
  <GenDir>$(ProjectDir)Generated</GenDir>
  <GppgExe>$(SolutionDir)libs\gppg\binaries\gppg.exe</GppgExe>
  <GplexExe>$(SolutionDir)libs\gppg\binaries\gplex.exe</GplexExe>
</PropertyGroup>
<Target Name="BeforeBuild"
        Outputs="$(GenDir)\parser.cs;$(GenDir)\lexer.cs"
    DependsOnTargets="BuildGen"></Target>
<Target Name="AfterClean"
        DependsOnTargets="CleanGen"></Target>
<Target Name="CleanGen">
  <Delete Condition="Exists('$(GenDir)')"
        Files="$(GenDir)\parser.cs;$(GenDir)\lexer.cs;$(GenDir)\parser.errors.txt;"
    TreatErrorsAsWarnings="true"></Delete></Target>
<Target Name="BuildGen"
        Outputs="$(GenDir)\parser.cs;"
    DependsOnTargets="GenerateParser"></Target>
<Target Name="CreateGenDir">
  <MakeDir Directories="$(GenDir)"
         Condition="!Exists('$(GenDir)')" /></Target>
<Target Name="GenerateParser"
        DependsOnTargets="CreateGenDir"
    Inputs="$(ParserDir)\parser.y"
    Outputs="$(GenDir)\parser.mppg.cs">
  <Message Text="Generating $(GenDir)\lexer.cs..." />
  <Exec Command="&quot;$(GplexExe)&quot; &quot;/out:$(GenDir)\lexer.cs&quot; &quot;$(ProjectDir)lexer.lex&quot;"
      WorkingDirectory="$(ProjectDir)"
    Outputs="$(GenDir)\lexer.cs" />
  <Message Text="Generating $(GenDir)\parser.cs..." />
  <Exec Command="&quot;$(GppgExe)&quot; /gplex &quot;$(ProjectDir)parser.y&quot; &gt; &quot;$(GenDir)\parser.cs&quot; 2&gt;&quot;$(GenDir)\parser.errors.txt&quot;"
      WorkingDirectory="$(ProjectDir)"
    Outputs="$(GenDir)\parser.cs">
    <Output TaskParameter="Outputs"
          ItemName="ParserMppg" /></Exec></Target>
{% endhighlight %}

One more step. Open the "cflat" solution and add a new reference to the cflat
project by browsing to your libs folder down to
libs\gppg\binaries\QUT.ShiftReduceParser.dll. That contains code that our
parser will need to do its magic.

Build it!

Now, in the Solution Explorer, enable "Show All Files." A directory named
"Generated" should appear in the solution tree. You should find "lexer.cs" and
"parser.cs" in the "Generated" directory. Right-click each of them and
"Include \[it\] In \[the\] Project".

We now have the basis for our C♭ compiler.

## Design decision - Transcompiler

Let's make this easy on ourselves and not build a compiler. Rather, let's
build a [transcompiler](http://en.wikipedia.org/wiki/Transcompiler) that will
emit valid C# that we can build with the `csc.exe` compiler. That'll reduce
a lot of the problems that we'd come across with writing an assembly to disk,
though we could build it in memory like Boo or use
[PERWAPI](http://perwapi.codeplex.com/).

## Starting with the basics

So, let's review the requirements that we have, so far, for C♭.

* All public methods for classes are static or property getters/setters.
* Methods only take one parameter and it's a lambda/Func/Action.
* The compiler fails to compile a file that contains less than 300 lines.
* The compiler fails to compile a file with any XML documentation.
* All property getters and setters are virtual.
* Declarations MUST use the `var` keyword.
* Global variables are allowed.
* Every class is `IDisposable`.
* All constructors must have at least one Boolean value.
* The compiler will automatically generate an interface for each class.

I don't have much more time, today, but we can definitely get one or two of
these done. Let's choose the 300 lines one. This one is kind of easy. So, our
command-line will accept a file name and, should that file have less than 300
lines, we'll fail.

In our Program file, let's read the first arg, for now, from the args and use
that as the file. Let's not over-engineer this.

{% highlight csharp %}
public static int Main(string[] args)
{
  if(args.Length == 0)
  {
    Console.Error.WriteLine("Specify a file, dude.");
    return 1;
  }
  using(Stream input = System.IO.File.Open(args[0]))
  {
    Parser p = new Parser(new Scanner(input));
    if(!p.Parse())
    {
      Console.Error.WriteLine(p.ErrorMessage);
      return p.ErrorCode;
    }
  }
}
{% endhighlight %}
